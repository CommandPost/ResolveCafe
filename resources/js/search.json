[[{"i":"#","p":["Resolve Cafe is a technical community for professional DaVinci Resolve editors."]},{"l":"Latest News","p":["Resolve Cafe is a technical community for professional DaVinci Resolve editors.","Want to contribute or advertise? Learn more here!","DaVinci Resolve Studio Scaling Fix Fix Scaling issues in DaVinci Resolve Studio for FCPX and Premiere sequences imported via XML and FCPXML. Purchase Here"]},{"l":"Tuesday 30th May 2023","p":["Following on from the interest in FCP Cafe, Chris at LateNite has thrown together this site to be a new \"home page\" and community for professional editors using DaVinCi Resolve.","We want this site to be:","Open: This site will remain open-source on GitHub for anyone to suggest pull requests","Up-to-date & Relevant: We want this site to always be up-to-date and relevant","No bullshit: We want this site to be honest, truthful, useful and professional","Community Driven: This isn't our site, it's \"owned\" by the professional DaVinci Resolve Community","Modern: This site should work great on the latest browsers, including mobile","Fast & Clean: This site should load quickly, and be easy to navigate","No analytics or user tracking: No cookies here!","This is still very much a work-in-progress, and we'll be adding content gradually over the coming weeks and months.","Want to contribute or advertise? Learn more here!"]}],[{"l":"Case Studies on Splice","p":["Blackmagic has some incredible case studies on their Slice Community."]}],[{"i":"tips--tricks","l":"Tips & Tricks","p":["This page will be dedicated to user supplied tips and tricks.","Want to contribute? Learn more here!"]}],[{"l":"Articles","p":["This section of the site is dedicated to linking to great external articles, as well as providing a space to write Resolve Cafe specific articles.","Want to contribute? Learn more here!"]}],[{"l":"Podcasts","p":["This page is dedicated to DaVinci Resolve podcasts."]},{"i":"color--coffee","l":"Color & Coffee","p":["Color & Coffee is a podcast focused on the craft of color grading hosted by colorist and finishing artist Jason Bowdach. Jason will host a variety of post-production professionals for intimate discussions on their craft, their passions, and of course, their favorite beverage of choice.","Want to contribute? Learn more here!"]}],[{"l":"History","p":["This section is dedicated to the history and backstory of DaVinci Resolve.","Want to contribute? Learn more here!"]}],[{"l":"Wish List","p":["This page is dedicated to keeping track of DaVinci Resolve feature requests, via our GitHub issues site."]},{"l":"Recently Added","p":["Here's a list of the 30 most recently added DaVinci Resolve feature requests:"]}],[{"l":"Bug Tracker","p":["This page is dedicated to keeping track of the latest DaVinci Resolve bugs and issues.","We keep track of these bugs via our GitHub issues site."]},{"l":"Recently Reported","p":["Here's a list of the 30 most recently reported DaVinci Resolve bugs on our GitHub issues site:"]}],[{"l":"Plugins","p":["This page is dedicated to DaVinci Resolve Plugins.","Want to contribute? Learn more here!"]}],[{"l":"Tools","p":["This page is dedicated to handy applications that can be used in conjunction with DaVinci Resolve.","Want to contribute? Learn more here!"]},{"l":"DaVinci Resolve Studio Scaling Fix","p":["Fix Scaling issues in DaVinci Resolve Studio for FCPX and Premiere sequences imported via XML and FCPXML.","You can learn more here."]}],[{"l":"Fusion Templates","p":["This will eventually be a directory of the best Fusion Templates.","In the meantime, we highly recommend Motion VFX."]}],[{"l":"Social Media","p":["This page is dedicated to DaVinci Resolve Social Media links."]},{"i":"postchatio","l":"postchat.io","p":["A place for all postproduction professionals, enthusiasts and anyone who wants to be part of Mastodon.","Run by the amazing Felipe Baez."]}],[{"l":"Training","p":["We're big fans of Ripple Training."]},{"l":"YouTube Videos","p":["Patrick Stirling produces DaVinci Resolve tutorials for streamers and beginners.","Jake Wipp creates high quality DaVinci Resolve tutorials and DaVinci Resolve presets.","Want to contribute? Learn more here!"]}],[{"l":"Control Surfaces","p":["This page is dedicated to Control Surfaces in DaVinci Resolve.","We will be adding reviews and information here in the future.","Want to contribute? Learn more here!"]}],[{"i":"davinci-color-transform-language-dctl","l":"DaVinci Color Transform Language (DCTL)"},{"i":"introduction","l":"Introduction:","p":["This documentation provides a quick reference and showcase of the DaVinci Color Transform Language (DCTL) - including the syntax, API and capabilities.","The DCTL syntax is C-like with additional definitions. Users can define functions using DCTL code to create a video effect, save it to file, and run it in Resolve. Such an effect serves as a \"pixel shader\" program - i.e. it defines a process to generate one pixel of data at a time at each given frame's coordinates. DCTL code is GPU accelerated in DaVinci Resolve across different platforms and graphics sub-systems.","In Resolve, DCTL effects can be run as a color LUT, using the DCTL OFX plugin or the Transition Plugin. DCTL effects are commonly saved as a plain text .dctl files, but if needed, developers can further save an encrypted effect as a .dctle file for distribution. See Encryption under Types of DCTLs.","For simplicity, the document uses the term \"a DCTL\" to refer to a logical unit (a program or function or an effect) and the more generic \"DCTL\" or \"DCTL code\" to refer to the language and syntax."]},{"i":"types-of-dctls","l":"Types of DCTLs:","p":["There are two main types of DCTLs:- A transform DCTL applies an effect to each frame of a single clip.- A transition DCTL applies an effect that blends frames from two clips over time.","A Transform DCTL performs a color transform or creates an effect (e.g increasing a frame's brightness - refer to the Gain.dctl example included). Users can apply the Transform DCTL in 4 ways:","A Transition DCTL creates a scene transition, such as a dissolve blending between 2 clips (refer to DissolveTransition.dctl sample). Transition DCTLs can only be used in the OpenFX DCTL Transition Plugin (which is located in [Resolve > Edit Page > OpenFX > Transition > ResolveFX Color > DCTL ]). The DCTL transition plugin is used in the same way as any other transition plugins (Resolve's Video Transitions, OpenFX transitions,...). After adding the plugin, users can select a DCTL file from the DCTL List and the corresponding transition effect will be applied."]},{"l":"Encryption","p":["In Resolve, users can encrypt a .dctl file with an expiry date to distribute an effect without revealing the content. The encrypted .dctle can be distributed and used normally in any of Resolve's systems until it expires.","To encrypt a DCTL: From the LUT browser, select the desired .dctl file, open context menu, choose \"Encrypt DCTL\" option. A helper dialog will appear for user to set name, expiration date and output folder for the encrypted DCTL. The encrypted DCTL will have a .dctle extension."]},{"i":"dctl-syntax","l":"DCTL Syntax:","p":["DCTL is similar to C in syntax, and uses base C types - int, float, char*, pointer etc. Some familiarity with C programming language terminology is helpful when reading this documentation.","Additional DCTL types include the following: TEXTURE- type for a texture reference. float2, float3 and float4 - vector types of 2 3 and 4 float values respectively. The utility functions make_float2(float,float), make_float3(float,float,float) and make_float4(float,float,float,float) can be used to contruct them.","These qualifiers are used DEVICE- qualifier to define a function. CONSTANT- qualifier to define a constant memory. CONSTANTREF- qualifier for a constant memory parameter passed to a function.","Structures can be defined using \"typedef struct\" syntax, Example:","Use CONSTANT to qualify constant memory variables.","To pass the constant memory as a function argument, use CONSTANTREF qualifier.","The DCTL programming environment also allows read-only access to multiple global constants. These are described in context in the sections below."]},{"i":"the-main-entry-function","l":"The Main Entry Function:","p":["Each DCTL file must use a single main entry function called 'transform()' or 'transition()', with the function signatures shown below. NOTE: Use the function definition below exactly as-is - including parameter types and names.","The Transform entry function for a Transform DCTL should be one of:","Description: This function performs a pixel transformation at offset (p_X, p_Y) on a single image (0, 0, p_Width, p_Height) with the input parameters provided.","Parameters:* p_Width and p_Height - the image resolution.* p_X and p_Y - the pixel coordinates where the transform function does the color transformation.* The (p_R, p_G, p_B) - input pixel's RGB values (in the first signature).* The (p_TexR, p_TexG, p_TexB) in the second signature - texture references to the RGB planes. The function can request the RGB values for any pixel from the image by calling _ tex2D([textureVariable], [posX], [posY]), which returns a float value (posX and posY being the desired input pixel coordinates).","Returns: Both transform functions return a float3 (RGB) value for each pixel at the coordinates (p_X, p_Y) for the result image.","The Transition function for a Transition DCTL uses the following signature:","Description: This function performs a blend from one clip (the 'From' clip : the clip fading out) to another (the 'To' clip : the clip fading in) over time.","As the transition progresses, the DCTL logic selects the appropriate image from the 'From' and 'To' clips and calls this function for each blend request. The global read-only float variable 'TRANSITION_PROGRESS', ranging from 0 (transition about to start) to 1 (transition has ended), can be used from within the function to monitor the progress of the transition. See the \"Other DCTL Keywords\" section.","Parameters:* p_Width and p_Height - the output image resolution.* p_X and p_Y - output pixel coordinates where the blend results are stored.* (p_FromTexR, p_FromTexG, p_FromTexB) - RGB texture references for the 'From' clip's image at TRANSITION_PROGRESS.* (p_ToTexR, p_ToTexG, p_ToTexB) - RGB texture references for the 'From' clip's image at TRANSITION_PROGRESS. Similar to the second transform signature, the function can access RGB values for any pixel in the \"From\" and \"To\" textures using the _ tex2D([textureVariable], [posX], [posY]) function.","Returns: The transition function returns a float4 (RGBA) value for each pixel at the coordinates (p_X, p_Y) for the result image."]},{"l":"Including Headers","p":["You can add commonly used DCTL logic to be called in multiple effects in a header file. To include a header, add the entry:","The path and the location of the headers are relative to the location of DCTL file.","Once included, the functions in this header file can now be referenced and used after the inclusion point."]},{"i":"defining-and-using-luts","l":"Defining and Using LUTs:","p":["Look Up Tables (LUTs) can be referenced from external files, and applied using the DEFINE_LUT and APPLY_LUT functions.","Parameters:- [lutName] is the user-defined name of the LUT- [lutPath] is the path to the external LUT file. Both absolute paths and paths relative to the DCTL location can be used.","Parameters:- (r, g, b) are LUT coordinates- [lutName] is the user-defined LUT name - this must match a prior DEFINE_LUT or DEFINE_CUBE_LUT call (see below).","As of DaVinci Resolve 17, LUTs can be defined inline using the DEFINE_CUBE_LUT function.","Parameters:- The [LUT_Content] should be wrapped with curly brackets '' and needs to follow the CUBE LUT standard format.- These LUTs can be applied in the same way as a referenced LUT - using the APPLY_LUT function.","The following rules apply:- LUTs must be defined in the DCTL file before use.- Multiple LUTs can be defined and applied in a single DCTL.- Multiple CUBE LUTs can be defined in a DCTL file and can be placed before or after the DCTL's Main Entry function.- LUT files must be in .cube format, with 1D or 3D LUTs, with/without shaper LUTs.- 1D LUT/Shaper LUTs will be applied with LINEAR interpolation method.- 3D LUTs will be applied with TRILINEAR or TETRAHEDRAL interpolation, as set in Resolve with [Project Settings > Color Management > 3D Lookup Table Interpolation ]."]},{"l":"Other DCTL keywords","p":["RESOLVE_VER_MAJOR and RESOLVE_VER_MINOR keys hold version values for checking and guarding version specific DCTL logic.","Example: For Resolve 17.0, RESOLVE_VER_MAJOR= 17 and RESOLVE_VER_MINOR= 0.#if (( RESOLVE_VER_MAJOR>= 17) && ( RESOLVE_VER_MINOR>= 0)) CallResolve17SpecificLogic();#else CallAlternativeLogic();#endif","DEVICE_IS_CUDA, DEVICE_IS_OPENCL, DEVICE_IS_METAL keys are defined for users to check and execute code conditionally in CUDA, OpenCL and Metal environments respectively. Example:#ifdef DEVICE_IS_CUDA DoSomethingCUDASpecific();#endif","For Transition DCTLs, the TRANSITION_PROGRESS key holds the progress of the current transition state as a float value with range [0.0f, 1.0f]. During the transition, DaVinci Resolve updates the TRANSITION_PROGRESS value and calls the transition main entry function for each image. The DissolveTransition.dctl example illustrates how to use this key."]},{"l":"Using DCTLs as Effects With Custom UI","p":["Custom DCTL effects (of the Transform DCTL type) can be added as plugins from Edit Page and Color Page effects libraries. To access them, double click or drag this plugin entry:- Edit page > Effects Library > OpenFX > Filters > ResolveFX Color > DCTL.- Color page > OpenFX > ResolveFX Color > DCTL. Once added, click the DCTL List combo box and select the desired DCTL effect to apply the effect.","To add new DCTL effects to this list, place the appropriate DCTL file in the DaVinci Resolve LUT directory. To edit a loaded DCTL effect,- navigate to the DaVinci Resolve LUT directory in a file browser.- load the appropriate DCTL file in a text editor to make changes.- Save the file.- In DaVinci Resolve's inspector, press \"Reload DCTL\" button to see the reflected result instantly.","DaVinci Resolve supports 5 types of UI elements. With the DEFINE_UI_PARAMS function, you can define custom controls for your DCTL plugins and link them to variables in the DCTL file. Float Slider: DEFINE_UI_PARAMS([variable name], [label], DCTLUI_SLIDER_FLOAT, [default value], [min value], [max value], [step]) Int Slider: DEFINE_UI_PARAMS([variable name], [label], DCTLUI_SLIDER_INT, [default value], [min value], [max value], [step]) Value Box: DEFINE_UI_PARAMS([variable name], [label], DCTLUI_VALUE_BOX, [default value]) Check Box: DEFINE_UI_PARAMS([variable name], [label], DCTLUI_CHECK_BOX, [default value]) Combo Box: DEFINE_UI_PARAMS([variable name], [label], DCTLUI_COMBO_BOX, [default value], [enum list], [enum label list])","Each DCTL plugin can have up to 64 UI controls for each type.","Parameters:- The [variable name] is linked with the UI element. This variable can be used inside the transform function.- The [label] text appears alongside the control and describes the control to the user of the DCTL.- The third parameter - the ui element enum - allows DaVinci Resolve to construct the appropriate UI control.- The [default value], [min value], [max value] and [step] are int-based (except for the Float Slider, where they are float)- The [enum list] - defined in curly brackets \"\" is available for use in the Main Entry function.- The [enum label list] - defined as string inside curly brackets \"\" is used to indicate the enum value in the UI. It must contain the same number of items as [enum list].","Examples: DEFINE_UI_PARAMS(gainR, Red Gain, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 10.0, 0.1) DEFINE_UI_PARAMS(iters, Iteration, DCTLUI_SLIDER_INT, 1, 0, 10, 1) DEFINE_UI_PARAMS(gain, Master Gain, DCTLUI_VALUE_BOX, 2.0) DEFINE_UI_PARAMS(apply, Apply, DCTLUI_CHECK_BOX, 1) DEFINE_UI_PARAMS(opt, Channel Option, DCTLUI_COMBO_BOX, 1, { RED, GREEN, BLUE }, { Channel Red, Channel Green, Channel Blue })","Changes to custom UI parameters - via user controls, Undo actions or from DCTL logic - are reflected both in the Resolve UI and in the DCTL variable."]},{"l":"Supporting math functions"},{"l":"List of floating-point math functions available","p":["float _ fabs(float x) # Returns the absolute value of x float _ powf(float x, float y) # Computes x raised to the power of y float _ logf(float x) # Computes the value of the natural logarithm of x float _ log2f(float x) # Computes the value of the logarithm of x to base 2 float _ log10f(float x) # Computes the value of the logarithm of x to base 10 float _ expf(float x) # Computes e x, the base-e exponential of x float _exp2f(float x) # Computes 2 x, the base-2 exponential of x float _ exp10f(float x) # Computes 10** x, the base-10 exponential of x float _ copysignf(float x, float y) # Returns x with its sign changed to y's float _ fmaxf(float x, float y) # Returns x or y, whichever is larger float _ fminf(float x, float y) # Returns x or y, whichever is smaller float _ clampf(float x, float min, float max) # Clamps x to be within the interval [min, max] float _ saturatef(float x) # Clamps x to be within the interval [0.0f, 1.0f] float _ sqrtf(float x) # Computes the non-negative square root of x float _ ceilf(float x) # Returns the smallest integral value greater than or equal to x float _ floorf(float x) # Returns the largest integral value less than or equal to x float _ truncf(float x) # Returns the integral value nearest to but no larger in magnitude than x float _ round(float x) # Returns the integral value nearest to x rounding, with half-way cases rounded away from zero float _ fmod(float x, float y) # Computes the floating-point remainder of x/y float _ hypotf(float x, float y) # Computes the square root of the sum of squares of x and y float _ cosf(float x) # Computes the cosine of x (measured in radians) float _ sinf(float x) # Computes the sine of x (measured in radians) float _ cospif(float x) # Computes the cosine of (x * pi) (measured in radians) float _ sinpif(float x) # Computes the sine of (x * pi) (measured in radians) float _ tanf(float x) # Computes the tangent of x (measured in radians) float _ acosf(float x) # Computes the principle value of the arc cosine of x float _ asinf(float x) # Computes the principle value of the arc sine of x float _ atan2f(float y, float x) # Computes the principal value of the arc tangent of y/x, using the signs of both arguments to determine the quadrant of the return value float _ acoshf(float x) # Computes the principle value of the inverse hyperbolic cosine of x float _ asinhf(float x) # Computes the principle value of the inverse hyperbolic sine of x float _ atanhf(float x) # Computes the inverse hyperbolic tangent of x float _ coshf(float x) # Computes the hyperbolic cosine of x float _ sinhf(float x) # Computes the hyperbolic sine of x float _ tanhf(float x) # Computes the hyperbolic tangent of x float _ fdimf(float x, float y) # Returns the positive difference between x and y: x - y if x > y, +0 if x is less than or equal to y float _ fmaf(float x, float y, float z) # Computes (x * y) + z as a single operation float _ rsqrtf(float x) # Computes the reciprocal of square root of x float _ fdivide(float x, float y) # Returns x/y float _ frecip(float x) # Returns 1/x int isinf(float x) # Returns a non-zero value if and only if x is an infinite value int isnan(float x) # Returns a non-zero value if and only if x is a NaN value int signbit(float x) # Returns a non-zero value if and only if sign bit of x is set T _ mix(T x, T y, float a) # T is used to indicate that the function can take float, float2, float3, float4, as the type for the arguments.# Returns: (x + (y - x) * a). \"a\" must be a value in the range [0.0f, 1.0f]. If not, the return values are undefined. float _ frexp(float x, int exp) # Extracts mantissa and exponent from x. The mantissa m returned is a float with magnitude in the interval [1/2, 1) or 0, # and exp is updated with integer exponent value, whereas x = m * 2exp float _ldexp(float x, int exp) # Returns (x * 2exp)","Note that float values must have 'f' character at the end (e.g. 1.2f)."]},{"l":"List of integer math functions available","p":["int abs(int x) # Returns the absolute value of x int min(int x, int y) # Returns x or y, whichever is smaller int max(int x, int y) # Returns x or y, whichever is larger"]},{"l":"Sample DCTLs"},{"l":"ACES DCTL","p":["ACES DCTLs allows user to define:- a standard color encoding (SMPTE ST 2065-1),- Input Transforms to convert different image sources to ACES,- Output Transforms in order to view ACES images on different types of displays. and use them to define the project's color science, or in Resolve FX ACES Transform for individual clips.","There are 2 types of ACES DCTL:- parametric ACES transforms- non-parametric ACES transforms (supported since DaVinci Resolve 17)."]},{"l":"Adding a Custom ACES IDT or ODT File","p":["Navigate to the \"ACES Transforms\" folder in Resolve's main application support folder.","MacOS: \"~/Library/Application Support/Blackmagic Design/DaVinci Resolve/ACES Transforms\" double check folders again","Windows: \"%AppData%\\Blackmagic Design\\DaVinci Resolve\\Support\\ACES Transforms\"","Linux: \"~/.local/share/DaVinciResolve/ACES Transforms\"","Place your custom ACES DCTL files for Input Device Transforms (IDTs) in the IDT subfolder.","Place your custom ACES DCTL files for Output Device Transforms (ODTs) in the ODT subfolder.","Start Resolve.","At start up, Resolve loads all the ACES DCTLs inside the \"ACES Transforms/IDT\" and \"ACES Transforms/ODT\" folders."]},{"l":"Using a Custom ACES IDT or ODT File","p":["Applying ACES transforms from Project Settings:- Color Science: select \"ACEScc\" or \"ACEScct\"- ACES Version: select ACES version 1.1 or above.- ACES Input Device Transform: select the required ACES DCTL IDT.- ACES Output Device Transform: select the required ACES DCTL ODT.","Applying ACES Transform plugins to individual clips:- Double click or drag this plugin entry:- Edit page > Effects Library > OpenFX > Filters > ResolveFX Color > ACES Transform.- Color page > OpenFX > ResolveFX Color > ACES Transform.- Once added, select the required ACES DCTLs from the Input Transform or Output Transform combo box."]},{"l":"Defining an ACES DCTL","p":["The basic ACES DCTL format is as follows:","Depending on its location, an ACES DCTL is interpreted as an IDT or an ODT. So the DEFINE_ACES_PARAM expands its parameters into either- float3 AcesInvOutputTransform(float p_R, float p_G, float p_B); // if the DCTL is an IDT- float3 AcesOutputTransform(float p_R, float p_G, float p_B); // if the DCTL is an ODT.","These functions can be called from the transform main entry function.","ACES DCTLs are written as transform DCTLs in one of three ways - using:- a non-parametric approach and hand-rolling your own transform functions.- a parametric ACES transform definition with standard ACES EOTFs.- a parametric ACES transform definition with custom EOTF functions. Example files for all three scenarios are available in the ACES Transform folder in the DCTL Developer documentation."]},{"l":"Writing a Non-Parametric ACES Transform","p":["Example files: IDT_Custom_sRGB.dctl and ODT_Custom_sRGB.dctl.","To define a Non-Parametric ACES transform (e.g. an IDT for new vendor camera, or an ODT for custom output screen), use the argument \"IS_PARAMETRIC_ACES_TRANSFORM: 0\". Example: DEFINE_ACES_PARAM(IS_PARAMETRIC_ACES_TRANSFORM: 0)","Once defined as non-parametric, all other parameter definitions in DEFINE_ACES_PARAM are ignored.","The user then defines either:","a custom IDT to convert the image source to the AP0 Linear colorspace, or","a custom ODT to convert incoming data from the AP0 linear colorspace.","invokes it from the main transform function."]},{"l":"Writing a Parametric ACES Transform","p":["Example Files: IDT_P3D65_108.dctl and ODT_P3D65_108.dctl","Parametric ACES transforms are supported under ACES version 1.1 or above. To write a parametric ACES transform following this standard, you need to define the following fields:- Y_MIN: black luminance (cd/m 2) - float. - Y_MID: mid-point luminance (cd/m 2) - float.- Y_MAX: peak white luminance (cd/m^ 2) - float.- DISPLAY_PRI: Display primaries - array of 8 floats inside curly brackets \"\".- LIMITING_PRI: Limiting primaries - array of 8 floats inside curly brackets \"\".- EOTF: Display device EOTF - integer in range [0-5] (see below)- INVERSE_EOTF: Input device EOTF - integer in range [0-5] (see below)- SURROUND: Viewing environment - integer (either 0,1) representing a boolean flag- STRETCH_BLACK: Stretch black luminance to a PQ code value of 0 - integer (either 0,1) representing a boolean flag- D60_SIM: Is user D60 adapted - integer (either 0,1) representing a boolean flag- LEGAL_RANGE: Output to legal range - integer (either 0,1) representing a boolean flag","Optional fields:- SKIP_STANDARD_ACES_RRT: Users can choose to run or skip standard ACES RRT (in output transform) or InvRRT (in input transform), and use their own custom RRT implementation. Integer (either 0,1) representing a boolean flag. By default, this value is treated as 0 and the standard ACES RRT (or InvRRT) is always used.","The EOTF and INVERSE EOTF fields correspond to the following Academy standard EOTF transforms:- 0: ST-2084 (PQ)- 1: BT.1886 (Rec.709/2020 settings)- 2: sRGB (mon_curve w/ presets)- 3: gamma 2.6- 4: linear (no EOTF)- 5: HLG The EOTF parameter value is used for ODT DCTLs and the INVERSE_EOTF parameter value is used for IDT DCTLs.","Example: DEFINE_ACES_PARAM(Y_MIN: 0.0001, Y_MID: 7.2, Y_MAX: 108.0, DISPLAY_PRI: { 0.68000, 0.32000, 0.26500, 0.69000, 0.15000, 0.06000, 0.31270, 0.32900 }, LIMITING_PRI: { 0.68000, 0.32000, 0.26500, 0.69000, 0.15000, 0.06000, 0.31270, 0.32900 }, EOTF: 0 , INVERSE_EOTF: 0, SURROUND: 0, STRETCH_BLACK: 1, D60_SIM: 0, LEGAL_RANGE: 0, SKIP_STANDARD_ACES_RRT: 0)"]},{"l":"Writing a Parametric ACES Transform with Custom Functions","p":["Example Files: IDT_CustomEOTF.dctl and ODT_CustomRRT.dctl","To write custom functions for your Parametric ACES Transform,","Write the parametric definition as above.","Define two functions for EOTF and INVERSE_EOTF transforms.","In the parametric definition, replace the (int) parameter values for EOTF and INVERSE_EOTF with the function names.","Example:","The second parameter in the custom functions is an input struct encapsulating the same parameters that you have defined using DEFINE_ACES_PARAM. typedef struct AcesTransformUserSettingParams{ float yMin; // Black luminance (cd/m 2) float yMid; // Mid-point luminance (cd/m 2) float yMax; // Peak white luminance (cd/m^ 2) float displayPri[8]; // Display primaries float limitingPri[8]; // Limiting primaries int eotf; // Display device EOTF int surround; // Viewing environment int stretchBlack; // Stretch black luminance to a PQ code value of 0 int d60Sim; // Is user D60 adapted int legalRange; // Output to legal range int skipRRT; // Skip the standard ACES RRT transform} AcesTransformUserSettingParams;","The ACES DCTL format follows the DCTL coding standard with extra options for users to define ACES parametric and non-parametric transforms, custom EOTF functions and custom RRT/invRRT functions."]},{"l":"Invoking Parametric Transforms from the Main Transform Function","p":["To apply the ACES transform, call the generated AcesOutputTransform or AcesInvOutputTransform in the DCTL's main transform function:","For Output Transforms: DEVICE float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B){ const float3 result = AcesOutputTransform(p_R, p_G, p_B); return result;}","For Input Transforms: DEVICE float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B){ const float3 result = AcesInvOutputTransform(p_R, p_G, p_B); return result;}","If you have set \"SKIP_STANDARD_ACES_RRT: 1\", you will need to chain in the custom RRT or Inverse RRT as an additional step. Example:","Output Transform: DEVICE float3 customRRT(float p_R, float p_G, float p_B){// RRT implementation code}","Input Transform: DEVICE float3 customInvRRT(float p_R, float p_G, float p_B){// InvRRT implementation code}"]},{"l":"Example ACES DCTLs"},{"l":"CHANGELOG","p":["Resolve 17.0- Support ACES DCTL.- Introduce _ ceilf() and _ floorf() functions which implicitly cast the input value to floating-point value and return floating-point result. Older version DCTL that uses deprecated _ ceil() and _ floor() functions are required to explicitly cast the input type to floating-point.- Support inline CUBE LUTs."]}],[{"l":"DaVinci Resolve IO Encode Plugin SDK"},{"l":"Getting Started","p":["The DaVinci Resolve IO Encode Plugin SDK enables development of additional codecs and container formats that can be rendered directly from DaVinci Resolve. These plugins can be distributed directly to customers who can use these in supported versions of DaVinci Resolve Studio. Currently, only CPU based plugins are supported."]},{"l":"Plugin Format","p":["Plugins should be distributed in the following format:","Mac: 64-bit dynamic library","Linux: 64-bit shared object","Windows: 64-bit DLL"]},{"l":"Plugin Packaging","p":["The plugin binary must be packaged in a bundle folder structure (similar to a Mac binary bundle). A single bundle may contain the plugin libraries for one or more architectures. The expected directory hierarchy is as follows:","where:","PLUGIN is the name of the plugin (the exact name should be used in both the bundle and binary name)","ARCH_x is the name of the architecture","The supported architectures on each operating system are:","Mac: MacOS - for Apple Universal2 binaries (x86_64 + Arm64) or Arm64 build","Mac: MacOS-x86-64 - on Intel only machines, this folder will be checked first, and if not found or empty, the MacOS folder will be checked","Linux: Linux-x86-64","Windows: Win64"]},{"l":"Example Plugin","p":["The 'Examples' folder contains a sample plugin for the x264 encoder in the folder named 'x264_encoder_plugin'.","Compile the x264 plugin from source (downloadable from here)","Modify .mk.defs(for Mac/Linux) or plugin2015.vcxproj(for Windows) in x264_encoder_plugin to point to the location of x264 install path.","From the x264_encoder_plugin folder, build the plugin via make on Mac/Linux, or using Visual Studio on Windows.","After the plugin has been successfully built, the target plugin library will be placed in the build folder. Package the plugin binary as per the naming convention above. For example:","Mac: x264_encoder_plugin.dvcp.bundle/Contents/MacOS-x86-64/x264_encoder_plugin.dvcp","Linux: x264_encoder_plugin.dvcp.bundle/Contents/Linux-x86-64/x264_encoder_plugin.dvcp","Windows: x264_encoder_plugin.dvcp.bundle/Contents/Win64/x264_encoder_plugin.dvcp","To activate the plugin in Resolve, copy 'x264_encoder_plugin.dvcp.bundle' folder to Application Support folder, into the 'IOPlugins' subfolder. The exact location is as follows:","Mac: /Library/Application Support/Blackmagic Design/DaVinci Resolve/IOPlugins","Mac (AppStore): ~/Library/Containers/com.blackmagic-design.DaVinciResolveAppStore/Data/Library/Application Support/IOPlugins","Linux: /opt/resolve/IOPlugins","Windows: %ProgramData%\\Blackmagic Design\\DaVinci Resolve\\Support\\IOPlugins","Once the plugin folder is installed, start Resolve and create a timeline with clips. Go to the Deliver page. In the format list, the list of containers supported by the plugin should show up. If a plugin supported container format (or QuickTime) is chosen, codecs supported by the plugin should be visible in the codecs list. Upon selecting the plugin codec, the corresponding UI widgets will be shown in the render settings."]}],[{"l":"Fusion Fuse","p":["You can find the Fusion Fuse Manual via the Help > Documentation > Developer > Fusion Fuse menubar item in DaVinci Resolve.","Want to contribute? Learn more here!"]}],[{"l":"Fusion Templates"},{"l":"Fusion Transitions","p":["Fusion transitions are templates built using Fusion tools. This added functionality gives you the freedom to create custom looks and designs that are traditionally not available on the Edit and Cut pages. Creating these templates can be done within Resolve's Fusion page, and when saved as a macro, your custom templates can be accessed on the Edit or Cut pages ready for use.","For more information about creating macros refer to Chapter 59 of the manual.","When creating a Fusion transition it's important to know that the animation and duration will be driven by the transition curve and edit length on the Edit & Cut pages. Fusion transitions animated with normal fixed-time keyframes will not adapt to other edit durations, so it's recommended to use adaptable modifiers such as Anim Curves instead.","When building a transition, instead of clicking the keyframe diamond on controls you want to animate, add the Anim Curves modifier with the \"Modify With\" item on the control's right-click context menu. This will create simple linear animation over the duration of the transition, which you can then customize using the controls in the Modifiers tab of the Inspector. Various preset and customizable curves are available, with options for scaling the values and timing of the curve. See the Anim Curves Modifier section below for more details."]},{"l":"Building a Transition","p":["As an example, to create a simple cross dissolve, do the following:","Selecting the transition will show any available controls for customization in the Inspector. It is also possible to make deeper changes to the transition's tools by right-clicking on the transition, and selecting \"Open in Fusion Page\".","Choose \"Create Transition Preset\" from the transition's context menu to save all control and tool changes as a User preset transition, for later use in the Edit or Cut pages.","Tip: When saving the macro, use \"Save As Group...\" to create a macro that can be opened within the Fusion Nodes view, allowing changes to its internal tools."]},{"l":"Fusion Generators","p":["Similar to Fusion transitions, generators are templates created from a macro, but with no image inputs, and a single image output. Generators can be created from Fusion generator tools such as Background or Fast Noise, or 3D rendered scenes, particles etc, or any combination of Fusion and ResolveFX tools.","As with transitions, it is recommended that the Anim Curves modifier be used for any animation, instead of fixed keyframes. This enables any animation in the generator to adapt to the duration on the Edit and Cut pages. See the Anim Curve Modifier section below for details."]},{"l":"Fusion Titles","p":["Titles are a special case of Generator that create text. Either Text+ or Text3D tools may be used as desired, along with other Fusion and ResolveFX tools. Most title templates have the text tool's \"Styled Text\" control exposed when creating the macro, so that users may supply their own text in the Edit Inspector. Exposing the Font, Style, and Size controls may be desirable too, along with Color controls from the Shading tab and any other relevent controls.","Likewise, it is recommended that the Anim Curves modifier be used for any animation, instead of fixed keyframes. This enables any animation in the title template to adapt to the duration on the Edit and Cut pages. See the Anim Curve Modifier section below for details."]},{"l":"Fusion Effects","p":["Effects are a template with a single image input and a single output. Similar to an Adjustment Layer, they can apply any desirable effect to the clip they are applied to, but with exposed controls for customization, and with animation that adapts to the duration of the effect. Additionally, multiple Fusion Effects may be applied to a single clip, and re-ordered as desired. To edit the controls of a Fusion Effect, select the clip it is applied to, then click the Effects tab in the Edit page Inspector.","As with other templates, it is recommended that the Anim Curves modifier be used for any animation, instead of fixed keyframes. This enables any animation in the effect to adapt to the duration on the Edit and Cut pages. See the Anim Curve Modifier section below for details."]},{"l":"Bundled Assets","p":["As of 17.2, Resolve allows various asset files to be included and used with your template. This includes image files of some supported formats (PNG, JPG, EXR, TGA, BMP) for logos, watermarks, particles etc, 3D objects and cameras in an FBX file, and LUTs. These can be used with Fusion tools including Loader, FBX Mesh 3D, and File LUT. For ease of portability and user installation, the new \"Setting:\" path map has been provided, which is valid inside templates and other macros & tool groups that have been loaded from a .setting file, and points to the same folder that the .setting file is in.","For example, a Loader set to \"Setting:leaf.jpg\" could provide an image source for a particle system, so long as the leaf.jpg file was in the same folder as the template .setting file containing the Loader, or an FBX Mesh tool could use \"Setting:Models/object.fbx\" to get an object from a Models subfolder."]},{"l":"The Anim Curves Modifier","p":["Anim Curves Controls:","Back","Bounce","Circ","Clip High: Ensure the output value never exceeds 1.0","Clip Low: Ensure the output value never dips below 0.0","Cubic","Curve: allows the following curve shape choices:","Custom: Displays an editable curve control allowing full customization of the animation","Custom: Timing can be controlled manually by a spline or other modifier on the revealed Input control","Duration: Animation is timed to match the duration of the edit","Easing: Allows selection from a number of preset curve shapes, for ease-in, ease-out, or both:","Elastic","Expo","Invert: The curve is flipped upside-down, so that the values start high and end low","Linear: Simple linear animation","Mirror: The animation curve is mirrored so that after reaching the end, it returns to the starting value","None (linear or no easing)","Offset: Adds to the default 0..1 output value, to allow animation over a specific range of values","Quad","Quart","Quint","Scale: Multiplies the default 0..1 output value, to reduce or increase the effect of the control","Sine","Source: allows the following timing choices:","The Anim Curves modifier is designed to allow easy creation of animation for transition and effect templates, and will speed up and slow down automatically to match the edit duration. It can also take the Edit page's Transition Curve easing into account, giving greater control to editors. It offers many preset curve shapes and combinations, including fully customized, with controls for scaling and timing the animation as well.","Time Offset: Delays the animation, as a fraction of its total duration","Time Scale: Speeds up or slows down the animation","Tip: The resulting animation curve can be seen in the Spline view, and is updated live as you change the controls. In the Spline view's tool tree, find the tool and select the name of the control you're animating to see the curve.","To use this animation modifier, right-click on a control in the Inspector, then select Anim Curves from the list of modifiers (choose Modify With > Anim Curves).","Transition: Like Duration, but values are shaped by the Edit page's Transition Curve"]},{"l":"Template Icons","p":["As of 17.2, Resolve supports an included .png image file with the same name as your .setting file, and will use this as your template's icon in the Resolve user interface. The recommended size is 104 x 58, but will be resized to suit. For example, a LogoPop.setting will use a LogoPop.png icon in the same dir."]},{"l":"Template Paths","p":["Fusion templates are stored in subdirectories within the OS specific directory described below:","Your template should be saved in one of the following subdirectories, according to its purpose:- Transitions- Titles- Generators- Effects","Please note that the folders for custom Fusion templates can also be located using the option \"Show Folder\" available in the 3 dot menu in \"Effects Library\" on the Fusion page. Select the desired template category, choose the Show Folder menu option, and a system file manager window will be opened at the proper path.","It is also possible to import template files by opening the Fusion page Effects Library to the appropriate category, then dragging and dropping the template file onto the list of templates. A restart of Resolve may be required for it to show up in the Edit and Cut pages."]},{"l":"DRFX Bundles","p":["As of 17.2, multiple templates may now be bundled together in .drfx files, which are ordinary zip files with a renamed extension (plain .zip files are supported too, with different naming in the UI). These may be organised into subfolders within the zip, if desired, and can also include icons for each template, and any associated assets, for ease of distribution and installation of one or more templates in a single file."]}],[{"l":"Cube LUT Format Specification","p":["A Cube file is a text file with extension \".cube\". It contains 2 parts: the header and the content. The header defines the properties of the LUT, while the content holds lookup table transformation data. The content section starts on a new line directly after last header definition.","The Cube LUT format supports 1D and 3D lookup tables, with an optional shaper LUT preceding it."]},{"l":"1D LUT","p":["A 1D lookup table allows output values to be specified corresponding to equally spaced input values in a given range. In the header of the LUT, the size and range of the LUT can be specified as follows:","LUT_1D_SIZE N LUT_1D_INPUT_RANGE MIN_VAL MAX_VAL","where: N - number of entries, up to a maximum of 65536 MIN_VAL - floating point input value corresponding to the first entry in the lookup table MAX_VAL - floating point input value corresponding to the last entry in the lookup table","The lookup data follows the header and contains as many entries as specified in the size entry in the header. Each line contains 3 space separated floating point values corresponding to the R, G and B output values respectively.","The first line of data corresponds to the minimum input value specified in the header, and the last line corresponds to the maximum input value. In between lines corresponds to monotonically increasing scaled values of the input. For example, if a LUT has size of 6 with minimum value 0.0 and maximum value 1.0, then the 6 lines of the table would correspond to input values 0.0, 0.2, 0.4, 0.6, 0.8 and 1.0 respectively.","For any input values that are not explicitly mapped in the table, the result is linearly interpolated between the nearest available values (i.e nearest entry higher than the input and nearest entry lower than the input) in the table."]},{"l":"3D LUT","p":["A 3D lookup table is conceptually similar to a 1D LUT except that it allows for a lookup to be performed along each of the 3 color axes. This gives the user the ability to model a transformation where a change in one color channel may cause a change in the other two color channels as well.","Similar to a 1D LUT, the header contains information about the size of the lookup table as well as the range of input values.","LUT_3D_SIZE N LUT_3D_INPUT_RANGE MIN_VAL MAX_VAL","where: N- number of entries per channel (NOTE: this results in a lookup table that has N * N * N entries) MIN_VAL- floating point input value corresponding to the first entry in the lookup table MAX_VAL- floating point input value corresponding to the last entry in the lookup table","The lookup data follows the header and contains N * N * N entries for a size N specified in the header. Each line contains 3 space separated floating point values corresponding to the R, G and B output values respectively.","The first line of data corresponds to the minimum input value specified in the header for all 3 channels, and the last line corresponds to the maximum input value for all 3 channels. In between lines corresponds to monotonically increasing scaled values of the input, with R values changing most rapidly. For example, if a LUT has size of 6 with minimum value 0.0 and maximum value 1.0, then the entries would correspond to all combinations of the 6 possible values for each input channel: 0.0, 0.2, 0.4, 0.6, 0.8 and 1.0 respectively.","The first 6 values would correspond to increasing values of R (from minimum to maximum), while G and B are 0.0. The next 6 values would correspond to increasing values of R (again starting from the minimum value) while G is 0.1 and B is 0.0. Once all values of G are covered, B in increased to the next possible value and the whole sequence is repeated. This continues until all combinations are covered.","In a 3D LUT, the 3 color components of the input value are used to find the nearest indexed values along each axis of the 3D cube. The 3-component output value is calculated by interpolating within the volume defined by the nearest corresponding positions along each axis in the LUT. Resolve supports 2 types of interpolation for 3D LUTs - trilinear interpolation and tetrahedral interpolation."]},{"l":"Shaper LUT","p":["A LUT samples each of the axes in a uniform manner. However, there may be cases where more precision is needed in a specific region of the input range as opposed to the rest of it. In such cases, a shaper LUT can be used to re-map the input range as a pre-processing step in order to make better use of the LUT samples. Such an operation can be done using a 1D LUT and is called a shaper LUT. Shaper LUTs can be applied before either a 1D LUT or a 3D LUT. It is defined in the same way as a 1D LUT, and is defined first before the actual LUT."]},{"l":"Optional Properties","p":["Comments and descriptions can be inserted at any point. The line needs to start with the # character. Such lines are ignored by the parser.","A LUT can be given a descriptive title using the TITLE keyword as follows:","TITLE Description","In Resolve, LUTs are applied in data range (0.0 to 1.0). The input data is in data range, and the LUT is expected to output in data range. However, there may be LUTs that are designed to operate on and/or output video range data (64 - 940 in 10-bit scale). To handle these cases, there are two properties which can be used to notify Resolve that the input/output is in video range. Based on this, Resolve will handle the input/output values so that it works correctly in a data range processing pipeline. Depending on the LUT, one or both of these properties can be specified by having the keywords below on a new line.","LUT_IN_VIDEO_RANGE","LUT_OUT_VIDEO_RANGE"]},{"l":"Examples","p":["Please look for these example files in DaVinci Resolve's installation folder.","On MacOS, they are located at:","1D LUT: /Library/Application Support/Blackmagic Design/DaVinci Resolve/LUT/VFX IO/Linear to Cineon Log.cube","3D LUT: /Library/Application Support/Blackmagic Design/DaVinci Resolve/LUT/Blackmagic Design/Blackmagic 4.6K Film to Rec709.cube","Shaper LUT: /Library/Application Support/Blackmagic Design/DaVinci Resolve/LUT/ACES/LMT ACES v0.1.1.cube","On Linux, they are located at:","1D LUT: /opt/resolve/LUT/VFX IO/Linear to Cineon Log.cube","3D LUT: /opt/resolve/LUT/Blackmagic 4.6K Film to Rec709.cube","Shaper LUT: /opt/resolve/LUT/ACES/LMT ACES v0.1.1.cube","On Windows, they are located at:","1D LUT: %PROGAMDATA%\\Blackmagic Design\\DaVinci Resolve\\LUT\\VFX IO\\Linear to Cineon Log.cube","3D LUT: %PROGAMDATA%\\Blackmagic Design\\DaVinci Resolve\\LUT\\Blackmagic Design\\Blackmagic 4.6K Film to Rec709.cube","Shaper LUT: %PROGAMDATA%\\Blackmagic Design\\DaVinci Resolve\\LUT\\ACES\\LMT ACES v0.1.1.cube"]}],[{"l":"OpenFX"},{"l":"Introduction","p":["OpenFX, also known as The Open Effects Association (OFX), is an open standard for visual effects plug-ins, and the interface between effects plug-ins and digital compositing systems. Established to facilitate the development of creative and efficient effects in post-production processes, it represents a significant advancement in the visual effects and video editing industry.","Prior to OpenFX, plug-in developers had to create multiple versions of each plug-in for different video editing software, which was time-consuming and inefficient. OpenFX addressed this issue by providing a single, unified standard that software developers could use to create plug-ins compatible with all video editing systems that support the OpenFX standard.","The OpenFX standard includes a robust API (Application Programming Interface), which defines how to write an effect plug-in and how host software should interact with these plug-ins. This API allows plug-ins to be written once and used across a range of different host applications.","OpenFX covers a broad scope of applications, including image processing, 2D and 3D effects, color correction, and more. Its strength lies in its versatility and platform neutrality, promoting a more integrated and efficient workflow in video editing and post-production processes. By creating an environment that allows seamless interplay between various software, OpenFX opens up possibilities for greater creativity and innovation in visual effects.","Blackmagic's DaVinci Resolve is a popular professional software for video editing, color correction, visual effects, and audio post-production. A significant feature of DaVinci Resolve is its strong support for OpenFX, allowing users to leverage an extensive variety of plug-ins to extend the capabilities of the software beyond its native functionality.","DaVinci Resolve's support for the OpenFX standard means that users can access a vast array of third-party effects plug-ins that conform to this standard. This means that, in addition to the robust set of tools available natively within DaVinci Resolve for color grading, visual effects, motion graphics, and audio post-production, users also have the flexibility to augment and customize their workflows with the specialized functionality that various OpenFX plug-ins provide.","The OpenFX plug-ins can be easily applied to clips on the timeline in DaVinci Resolve's Edit and Color pages, providing editors and colorists with the ability to perform more complex adjustments and effects directly within the software. This creates an integrated workflow that eliminates the need for round-tripping to other software for specific tasks, thereby increasing efficiency.","Moreover, DaVinci Resolve's support for OpenFX reflects Blackmagic's commitment to interoperability and customization, providing professionals with the flexibility they need to realize their creative visions. This level of compatibility helps ensure that DaVinci Resolve can adapt to a wide range of post-production workflows, catering to both individual creatives and larger collaborative teams."]},{"l":"Examples","p":["The Gyroflow OpenFX plugin is a great example of a very slick open-source OpenFX plugin that works great in DaVinci Resolve.","It's written in Rust and uses OpenFX bindings for Rust."]},{"l":"Sample Code","p":["[PluginName]::setupAndProcess() is called by [PluginName]::render(). It is used to setup all the parameters before invoking the image processor. Depending on the selected mode, the appropriate virtual methods ( processImagesCUDA, processImagesOpenCL, processImagesMetal and multiThreadProcessImages) will be invoked.","[PluginName].cpp- Contains the plugin factory class definition, plugin definition and the image processing algorithm","[PluginName].h- Contains the plugin factory class declaration","[PluginName].sln and GainPlugin.vcxproj- Visual Studio solution and project files","[PluginName].xcodeproj- Xcode project file","[PluginName]Factory::describe() is used to describe the plugin. For example, the supported bit depth and whether OpenCL, CUDA and Metal render capability is supported. User need to setup a appropriate OFX context based on expected effect behaviours (number of input clips it takes, and how it can interact with those input clips).","[PluginName]Factory::describeInContext() is used to describe the requirements of the clips and the parameters for the plugin.","After compilation, it will generate a directory named [PluginName].ofx.bundle. In order for Resolve to register this plugin, this directory needs to be copied to /Library/OFX/Plugins on the Mac OSX platform. On the Linux platform, this directory needs to be copied to /usr/OFX/Plugins.","CudaKernel.cu- Contains the CUDA kernel and the function to call the CUDA kernel","DissolveTransitionPlugin- Sample OpenFX plugin to demonstrate how to create a transition.","Finally, OFX::Plugin::getPluginIDs() is required to register the plugin.","For CUDA implementation, the plugin can operate on the cudaStream provided by the host and call p_Desc.setSupportsCudaStream(true) in [PluginName]Factory::describe(). If the plugin uses the default cudaStream or a stream created internally, it should set p_Desc.setSupportsCudaStream(false) and also perform synchronisation so that the GPU output buffers are ready when the plugin returns from the render call.","For the [PluginName]Factory class, there are three virtual methods ( describe, describeInContext and createInstance) that must be overridden.","GainPlugin- Sample OpenFX plugin using the CUDA, OpenCL and Metal render support.","GainPlugin::changedClip() is called when a clip has just changed.","GainPlugin::changedParam() is called when a parameter has changed its value.","GainPlugin::isIdentity() is used to indicate if processing is necessary with the given parameter set and rendering arguments.","In GainPluginFactory::describe(), p_Desc.setNoSpatialAwareness(true) is used to indicate that the plugin output does not depend on location or neighbours of a given pixel. Therefore, this plugin could be executed during LUT generation.","In the /Library/Application Support/Blackmagic Design/DaVinci Resolve/Developer/OpenFX folder on macOS, you can find the following subdirectories:","In the constructor, the handle to the input clips, output clips and required parameters are setup.","In the first part of [PluginName].cpp, there is a list of constants providing the details of the plugin. These are used to provide the information to the user when this plugin is selected.","In the next part, it creates a subclass of OFX::ImageProcessor. It has four virtual methods ( processImagesCUDA, processImagesOpenCL, processImagesMetal and multiThreadProcessImages) that can be overridden with your own implementation of processing algorithm on the GPU and CPU.","In the Plugin directory, the following project files are provided:","Makefile- Makefile for command line compilation","MetalKernel.mm- Contains the Metal kernel and the function to call the Metal kernel","Next, it creates a sublcass of OFX::ImageEffect:","OFX::eContextFilter requires single compulsory input, is used for a traditional 'filter effect' that transforms a single input (Refer to GainPlugin).","OFX::eContextTransition requires 2 compulsory input clips and a compulsory 'Transition' double parameter, is used to create transition effect between clips (Refer to DissolveTransitionPlugin).","On the Windows platform, the directory named GainPlugin.ofx.bundle is generated in the Debug/Release directory. This directory needs to be copied to C:\\Program Files\\Common Files\\OFX\\Plugins.","OpenCLKernel.cpp- Contains the OpenCL kernel and the function to call the OpenCL kernel","OpenFX-1.4- Contains the header files from the OpenFX package.","Other than the project files, there are four other files containing the source code for the plugin:","RandomFrameAccessPlugin- Sample OpenFX plugin using the CUDA, OpenCL and Metal render support with random frames access.","Support- Contains the header and source files from the OpenFX C++ wrapper package.","TemporalBlurPlugin- Sample OpenFX plugin using the CUDA, OpenCL and Metal render support with multiple frames access.","TemporalPlugin::getFramesNeeded() is called to set the clip's frame range that user wants to access.","Then, there are four virtual methods that are overridden. GainPlugin::render() must be overridden and is the plugin's render function.","This sample OpenFX plugin is capable of processing the images using the GPU (with CUDA or OpenCL or Metal) or the CPU. Other than the CUDA, OpenCL and Metal kernel implementation in CudaKernel.cu, OpenCLKernel.cpp and MetalKernel respectively, the rest of the plugin implementation details are in [PluginName].cpp."]}],[{"l":"Scripting","p":["This page is dedicated to Lua & Python scripting in DaVinci Resolve.","Whilst a lot of this page is currently just a \"copy and paste\" job from the existing documentation, the intention is to expand upon and enhance it - filling in all the gaps."]},{"l":"Community","p":["There's a really great community over at We Suck Less that discuss scripting in DaVinci Resolve."]},{"l":"Updated as of 17 May 2023","p":["In this package, you will find a brief introduction to the Scripting API for DaVinci Resolve Studio. Apart from this README.txt file, this package contains folders containing the basic import modules for scripting access ( DaVinciResolve.py) and some representative examples.","From v16.2.0 onwards, the nodeIndex parameters accepted by SetLUT() and SetCDL() are 1-based instead of 0-based, i.e. 1 <= nodeIndex <= total number of nodes."]},{"l":"Overview","p":["As with Blackmagic Design Fusion scripts, user scripts written in Lua and Python programming languages are supported. By default, scripts can be invoked from the Console window in the Fusion page, or via command line. This permission can be changed in Resolve Preferences, to be only from Console, or to be invoked from the local network. Please be aware of the security implications when allowing scripting access from outside of the Resolve application."]},{"l":"Prerequisites","p":["DaVinci Resolve scripting requires one of the following to be installed (for all users):","Lua 5.1","Python 2.7 64-bit","Python >= 3.6 64-bit"]},{"l":"Using a script","p":["DaVinci Resolve needs to be running for a script to be invoked.","For a Resolve script to be executed from an external folder, the script needs to know of the API location. You may need to set the these environment variables to allow for your Python installation to pick up the appropriate dependencies as shown below:"]},{"l":"macOS"},{"l":"Windows"},{"l":"Linux","p":["As with Fusion scripts, Resolve scripts can also be invoked via the menu and the Console.","On startup, DaVinci Resolve scans the subfolders in the directories shown below and enumerates the scripts found in the Workspace application menu under Scripts. Place your script under Utility to be listed in all pages, under Comp or Tool to be available in the Fusion page or under folders for individual pages (Edit, Color or Deliver). Scripts under Deliver are additionally listed under render jobs. Placing your script here and invoking it from the menu is the easiest way to use scripts."]},{"i":"macos-1","l":"macOS","p":["All users: /Library/Application Support/Blackmagic Design/DaVinci Resolve/Fusion/Scripts","Specific user: /Users/UserName/Library/Application Support/Blackmagic Design/DaVinci Resolve/Fusion/Scripts"]},{"i":"windows-1","l":"Windows","p":["All users: %PROGRAMDATA%\\Blackmagic Design\\DaVinci Resolve\\Fusion\\Scripts","Specific user: %APPDATA%\\Roaming\\Blackmagic Design\\DaVinci Resolve\\Support\\Fusion\\Scripts"]},{"i":"linux-1","l":"Linux","p":["All users: /opt/resolve/Fusion/Scripts(or /home/resolve/Fusion/Scripts/ depending on installation)","Specific user: $HOME/.local/share/DaVinciResolve/Fusion/Scripts","The interactive Console window allows for an easy way to execute simple scripting commands, to query or modify properties, and to test scripts. The console accepts commands in Python 2.7, Python 3.6 and Lua and evaluates and executes them immediately. For more information on how to use the Console, please refer to the DaVinci Resolve User Manual.","This example Python script creates a simple project:","The resolve object is the fundamental starting point for scripting via Resolve. As a native object, it can be inspected for further scriptable properties - using table iteration and \"getmetatable\" in Lua and dir, help etc in Python (among other methods). A notable scriptable object above is fusion - it allows access to all existing Fusion scripting functionality."]},{"l":"Running DaVinci Resolve in headless mode","p":["DaVinci Resolve can be launched in a headless mode without the user interface using the -nogui command line option. When DaVinci Resolve is launched using this option, the user interface is disabled. However, the various scripting APIs will continue to work as expected."]},{"l":"Basic Resolve API","p":["Some commonly used API functions are described below (*). As with the resolve object, each object is inspectable for properties and functions."]},{"l":"List and Dict Data Structures","p":["Beside primitive data types, Resolve's Python API mainly uses list and dict data structures. Lists are denoted by [ ... ] and dicts are denoted by { ... } above. As Lua does not support list and dict data structures, the Lua API implements \"list\" as a table with indices, e.g. { [1] = listValue1, [2] = listValue2, ... }. Similarly the Lua API implements \"dict\" as a table with the dictionary key as first element, e.g. { [dictKey1] = dictValue1, [dictKey2] = dictValue2, ... }."]},{"l":"Looking up Project and Clip properties","p":["This section covers additional notes for the functions Project:GetSetting, Project:SetSetting, Timeline:GetSetting, Timeline:SetSetting, MediaPoolItem:GetClipProperty and MediaPoolItem:SetClipProperty. These functions are used to get and set properties otherwise available to the user through the Project Settings and the Clip Attributes dialogs.","The functions follow a key-value pair format, where each property is identified by a key (the settingName or propertyName parameter) and possesses a value (typically a text value). Keys and values are designed to be easily correlated with parameter names and values in the Resolve UI. Explicitly enumerated values for some parameters are listed below.","Some properties may be read only - these include intrinsic clip properties like date created or sample rate, and properties that can be disabled in specific application contexts (e.g. custom colorspaces in an ACES workflow, or output sizing parameters when behavior is set to match timeline)"]},{"l":"Getting values","p":["Invoke Project:GetSetting, Timeline:GetSetting or MediaPoolItem:GetClipProperty with the appropriate property key. To get a snapshot of all queryable properties (keys and values), you can call Project:GetSetting, Timeline:GetSetting or MediaPoolItem:GetClipProperty without parameters (or with a NoneType or a blank property key). Using specific keys to query individual properties will be faster. Note that getting a property using an invalid key will return a trivial result."]},{"l":"Setting values","p":["Invoke Project:SetSetting, Timeline:SetSetting or MediaPoolItem:SetClipProperty with the appropriate property key and a valid value. When setting a parameter, please check the return value to ensure the success of the operation. You can troubleshoot the validity of keys and values by setting the desired result from the UI and checking property snapshots before and after the change.","The following Project properties have specifically enumerated values:","superScale- the property value is an enumerated integer between 0 and 3 with these meanings: 0=Auto, 1=no scaling, and 2, 3 and 4 represent the Super Scale multipliers 2x, 3x and 4x.","Affects: x = Project:GetSetting('superScale') and Project:SetSetting('superScale', x)","timelineFrameRate- the property value is one of the frame rates available to the user in project settings under \"Timeline frame rate\" option. Drop Frame can be configured for supported frame rates by appending the frame rate with \"DF\", e.g. \"29.97 DF\" will enable drop frame and \"29.97\" will disable drop frame","Affects: x = Project:GetSetting('timelineFrameRate') and Project:SetSetting('timelineFrameRate', x)","The following Clip properties have specifically enumerated values:","superScale- the property value is an enumerated integer between 1 and 3 with these meanings: 1=no scaling, and 2, 3 and 4 represent the Super Scale multipliers 2x, 3x and 4x.","Affects: x = MediaPoolItem:GetClipProperty('Super Scale') and MediaPoolItem:SetClipProperty('Super Scale', x)"]},{"l":"Looking up Render Settings","p":["[1 -> MAX] (int) - will set input bit rate","[Least, Low, Medium, High, Best] (String) - will set input quality level","0 (int) - will set quality to automatic","AlphaMode: 0 - Premultiplied, 1 - Straight. Can only be set if ExportAlpha is true.","AudioBitDepth: int","AudioCodec: string (example: aac)","AudioSampleRate: int","ColorSpaceTag: string (example: Same as Project, AstroDesign)","CustomName: string","EncodingProfile: string (example: Main10). Can only be set for H.264 and H.265.","ExportAlpha: Bool","ExportAudio: Bool","ExportVideo: Bool","FormatHeight: int","FormatWidth: int","FrameRate: float (examples: 23.976, 24)","GammaTag: string (example: Same as Project, ACEScct)","MarkIn: int","MarkOut: int","MultiPassEncode: Bool. Can only be set for H.264.","NetworkOptimization: Bool. Only supported by QuickTime and MP4 formats.","PixelAspectRatio: string (for SD resolution: 16_9 or 4_3) (other resolutions: square or cinemascope)","SelectAllFrames: Bool (when set True, the settings MarkIn and MarkOut are ignored)","TargetDir: string","The parameter setting is a dictionary containing the following keys:","This section covers the supported settings for the method SetRenderSettings({settings})","UniqueFilenameStyle: 0 - Prefix, 1 - Suffix.","VideoQuality possible values for current codec (if applicable):"]},{"l":"Looking up timeline export properties","p":["exportSubtype can be one of the following enums:","exportType can be one of the following constants:","Note: Replace resolve. when using the constants above, if a different Resolve class instance name is used.","Please note that exportSubType is a required parameter for resolve.EXPORT_AAF and resolve.EXPORT_EDL. For rest of the exportType, exportSubtype is ignored. When exportType is resolve.EXPORT_AAF, valid exportSubtype values are resolve.EXPORT_AAF_NEW and resolve.EXPORT_AAF_EXISTING. When exportType is resolve.EXPORT_EDL, valid exportSubtype values are resolve.EXPORT_CDL, resolve.EXPORT_SDL, resolve.EXPORT_MISSING_CLIPS and resolve.EXPORT_NONE.","resolve.EXPORT_AAF","resolve.EXPORT_AAF_EXISTING","resolve.EXPORT_AAF_NEW","resolve.EXPORT_CDL","resolve.EXPORT_DOLBY_VISION_VER_2_9","resolve.EXPORT_DOLBY_VISION_VER_4_0","resolve.EXPORT_DOLBY_VISION_VER_5_1","resolve.EXPORT_DRT","resolve.EXPORT_EDL","resolve.EXPORT_FCP_7_XML","resolve.EXPORT_FCPXML_1_10","resolve.EXPORT_FCPXML_1_8","resolve.EXPORT_FCPXML_1_9","resolve.EXPORT_HDR_10_PROFILE_A","resolve.EXPORT_HDR_10_PROFILE_B","resolve.EXPORT_MISSING_CLIPS","resolve.EXPORT_NONE","resolve.EXPORT_OTIO","resolve.EXPORT_SDL","resolve.EXPORT_TEXT_CSV","resolve.EXPORT_TEXT_TAB","This section covers the parameters for the argument Export(fileName, exportType, exportSubtype)."]},{"l":"Unsupported exportType types","p":["Starting with DaVinci Resolve 18.1, the following export types are not supported:","resolve.EXPORT_FCPXML_1_3","resolve.EXPORT_FCPXML_1_4","resolve.EXPORT_FCPXML_1_5","resolve.EXPORT_FCPXML_1_6","resolve.EXPORT_FCPXML_1_7"]},{"l":"Looking up Timeline item properties","p":["This section covers additional notes for the function TimelineItem:SetProperty and TimelineItem:GetProperty. These functions are used to get and set properties mentioned.","The supported keys with their accepted values are:","The arguments can be passed as a key and value pair or they can be grouped together into a dictionary (for python) or table (for lua) and passed as a single argument.","Getting the values for the keys that uses constants will return the number which is in the constant"]},{"l":"Deprecated Resolve API Functions","p":["The following API functions are deprecated."]},{"l":"Unsupported Resolve API Functions","p":["The following API (functions and parameters) are no longer supported. Use job IDs instead of indices."]}],[{"l":"Workflow Integrations"},{"l":"Overview","p":["DaVinci Resolve Studio now supports Workflow Integration Plugins to be loaded and communicate with Resolve. Resolve can run one or more Workflow Integration Plugins at the same time. Users can write their own Workflow Integration Plugin (an Electron app) which could be loaded into DaVinci Resolve Studio. To interact with Resolve, Resolve's JavaScript APIs can be used from the plugin.","Alternatively, a Python or Lua script can be invoked, with the option of a user interface built with Resolve's built-in Qt-based UIManager, or with an external GUI manager. See the \"Sample Workflow Integration Script\" section below for details."]},{"l":"Sample Workflow Integration Plugin","p":["A sample Workflow Integration Plugin is available in the Examples/SamplePlugin directory. In order for Resolve to register this plugin, this directory needs to be copied to Workflow Integration Plugins root directory (mentioned in below section). Once a plugin is registered, plugin can be loaded from UI sub-menu under Workspace > Workflow Integrations. This will load the plugin and show the plugin HTML page in a separate window.","Sample plugin helps to understand how a plugin should be structured and how it works with Resolve. Please refer to the directory/file structure, manifest file info, plugin loading, JavaScript API usage examples, etc. This sample plugin and scripts demonstrates few basic scriptable JavaScript API usages to interact with Resolve."]},{"l":"Loading Workflow Integration Plugin","p":["On startup, DaVinci Resolve Studio scans the Workflow Integration Plugins root directory and enumerates all plugin modules. For each valid plugin module, it creates a UI sub-menu entry under Workspace > Workflow Integrations menu. DaVinci Resolve Studio reads the basic details of the plugin from its manifest.xml file during load time. Once plugin is loaded, user can click on the Workflow Integrations sub-menu to load the corresponding plugin."]},{"l":"Workflow Integration Plugin directory structure"},{"l":"Workflow Integration Plugins root directory","p":["User should place their Workflow Integration Plugin under the following directory:"]},{"l":"macOS","p":["/Library/Application Support/Blackmagic Design/DaVinci Resolve/Workflow Integration Plugins/"]},{"l":"Windows","p":["%PROGRAMDATA%\\Blackmagic Design\\DaVinci Resolve\\Support\\Workflow Integration Plugins\\"]},{"l":"Supported platforms"},{"l":"Plugins","p":["Windows, macOS (not supported on Linux currently)"]},{"l":"Scripts","p":["Windows, Mac OS X, Linux"]},{"l":"Using scriptable JavaScript API","p":["Scriptable JavaScript API execution happens under HTML environment like any typical website. Once HTML page is loaded it can execute scriptable JavaScript API as needed (like clicking on a button, etc.)","This example JavaScript snippet creates a simple project in DaVinci Resolve Studio:","The resolve object is the fundamental starting point for scripting via Resolve. As a native object, it can be inspected for further scriptable properties and functions in JavaScript."]},{"l":"WorkflowIntegration module API","p":["To interact with Resolve you need to use WorkflowIntegration.node Node.js module file in your plugin app. Below are the WorkflowIntegration(module) JavaScript API functions to communicate with Resolve."]},{"l":"Supported callbacks","p":["RenderStart","RenderStop","Please note that there is no console based support for JavaScript API."]},{"l":"Sample Workflow Integration Script","p":["A sample Workflow Integration Python script is also available in the Examples directory. In order for Resolve to register this script, it needs to be copied to the Workflow Integration Plugins root directory (mentioned in the above section). Once a script is registered, it can be also loaded from the Workspace menu, under Workflow Integrations. This will invoke the script and show the sample UIManager window.","Workflow Integration scripts work similarly to other scripts in Resolve, and use the same scripting API. This example script provides a basic introduction into creating a popup Workflow application using a UIManager window, with simple layout of text fields and buttons, and event handlers to dispatch functions for integration with the user's facility. Alternatively, third-party UI managers such PyQt may be used instead, or no GUI at all.","When launched by Resolve, plugin scripts are automatically provided with resolve and project variables for immediate and easy access to Resolve's scripting API. Additional third-party modules may be imported for access to asset-management systems as desired."]},{"l":"UIManager Introduction","p":["There are two main objects needed to manage a window, the UIManager that handles layout, and the UIDispatcher that manages interaction events, accessed as follows:","Windows are created with the the UIDispatcher, passing a dictionary of attributes like ID and Text, with GUI elements in nested layouts all created with the UIManager."]},{"l":"UIDispatcher Functions","p":["The UIDispatcher object has a few important functions to manage processing of events. The most important are:","Common usage is to create your window and set up any event handlers, including a Close handler for the window that calls ExitLoop(), then Show() your window and call RunLoop() to wait for user interaction:","AddWindow() will also accept a single child without needing a list, or a single dictionary containing both proprties and child elements, for ease of use.","As well as constructing new child elements and layouts, the UIManager also offers a few useful functions:"]},{"l":"UIManager Elements","p":["The element's ID is used to find, manage, and dispatch events for that element. GUI elements also support a set of common attributes including Enabled, Hidden, Visible, Font, WindowTitle, BackgroundColor, Geometry, ToolTip, StatusTip, StyleSheet, WindowOpacity, MinimumSize, MaximumSize, and FixedSize. Some other common GUI elements and their main attributes include:","Some elements also have property arrays, indexed by item or column (zero-based), e.g. newItem.Text[2] = 'Third column text'","Some elements like Label and Button will automatically recognise and render basic HTML in their Text attributes, and TextEdit is capable of displaying and returning HTML too. Element attributes can be specified when creating the element, or can be read or changed later:","Most elements have functions that can be called from them as well:","Some elements have extra functions of their own:","Elements can be accessed by the window's FindWindow(id) function, or by assigning them to a variable for later usage, which is more efficient. The GetItems() function will return a dictionary of all child elements for ease of access."]},{"l":"UIManager Layout","p":["Additionally, elements can be nested to define layout, using the HGroup and VGroup elements. As with Window and other elements, tou can pass a single dictionary or list with all properties and children, or separate them into a dict of properties and list of children, for convenience:","HGap and VGap elements can included for finer spacing control. Note also the Weight attribute, which can be applied to most elements to control how they adjust their relative sizes. A Weight of 0 will use the element's minimum size."]},{"l":"Event Handlers","p":["Window objects will call user-defined event handler functions in response to various interaction events. Event handlers are managed using a window member called On. This has sub-members for each GUI element with an ID, and those have members for each available event. To set up an event handler, define a function for it, then assign the function to the window's On.ID.Event member as follows:","Alternatively, if your object's ID is stored in a string variable called buttonID, you could use:","Many objects have specific events that can be handled:","Event handler functions are called with a dictionary of related attributes such as who, what, when, sender, and modifiers. Common events and some additional attributes they receive include:","Event handlers can be enabled or disabled for a given element by turning them on or off in the Events attribute:","Some common events like Clicked or Close are enabled by default."]},{"l":"Basic Resolve API","p":["Please refer to the Basic Resolve API section in /Developer/Scripting/README.txt file for the list of the functions that Resolve offers for scripted control. For plugin scripts, the resolve and project variables are automatically set up for you, and may be used to access any part of Resolve's API."]},{"l":"Further Information","p":["This document provides a basic introduction only, and does not list all available UIManager elements and attributes. As UIManager is based on Qt, you can refer to the Qt documentation here for more information on element types and their attributes. There are also many third-party examples and discussions available on user forums for DaVinci Resolve and Fusion Studio."]}],[{"l":"Contribute","p":["Resolve Cafe is entirely open source and hosted on GitHub.","You can make changes to the site by submitting pull requests on GitHub.","We welcome and encourage users submitting their own case studies, articles and products.","The entire site is written in Markdown, so it's very easy to modify and update without knowing any HTML or code.","For example, you can just edit the contents of this page by clicking here.","For a basic overview of how you can do pull requests on GitHub check this page.","If you have questions, you can ask them on the Discussions board.","If you're not confident using GitHub, you can email us content here: support@latenitefilms.com"]},{"i":"advertising--sponsored-content","l":"Advertising & Sponsored Content","p":["We're open to promoting DaVinci Resolve products and services on the front page in a clean and useful way.","Please contact us to discuss: support@latenitefilms.com"]},{"l":"Powered by Retype","p":["Resolve Cafe is powered by Retype and hosted on GitHub Pages."]},{"l":"Our Mission","p":["We want this site to be:","Open: This site will remain open-source on GitHub for anyone to suggest pull requests","Up-to-date & Relevant: We want this site to always be up-to-date and relevant","No bullshit: We want this site to be honest, truthful, useful and professional","Community Driven: This isn't our site, it's \"owned\" by the professional DaVinci Resolve Community","Modern: This site should work great on the latest browsers, including mobile","Fast & Clean: This site should load quickly, and be easy to navigate","No analytics or user tracking: No cookies here!"]}],[{"l":"Credits","p":["Resolve Cafe was thrown together by Chris Hocking at LateNite Films.","The origin story comes back to this tweet, where Alex Gollner tweeted that \"fcp.co is no longer the Final Cut Pro watercoooler place\", and Chris replied with \"Screw it I just registered finalcutpro.tech. Lets do this thing!\".","Chris decided that FCP Cafe was a better name/domain, and as a result, that site was born.","Julien Chichignoud then said to Chris that DaVinci Resolve is \"definitely where the industry is going\" - and here we are.","Dan Svoboda also seemed to think it was a good idea."]}]]